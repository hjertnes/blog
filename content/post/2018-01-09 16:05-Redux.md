---
url: /post/acec609e-8792-487f-95bf-606b6b755ab6
date: 2018-01-09
title: "Redux"
---

Okay. So redux is a very simple solution to manage state. It has a few different parts, but none of them are difficult to understand, and it is very easy to work with. I don&#8217;t think I ever see any bugs in that part of my code bases.



Let&#8217;s begin with the reducer. A redux setup consists of one or more reducers. A reducer is a function, plus the inital state. The reducer function is usually a large or small switch / case. You are free to write it exactly how you like, but it has to return a new version of your state, and it recieves a object as input.



The typical way to do it is to use a TYPE key in the object to tell what kind of change it is, and then some additional data, if needed.



Important: input to a reducer is a pure object, and the output is a pure object.



Then you have your actions, this is the stuff inside the switch / case.



Then you have action-creators. These are functions that you use, and the result is that an action is invoked on the reducer. For example: load data from backend, and then add that data to the store.



This is the important part. You create a redux store, with one or more reducers. This is a instance of your store. Then you can use the dispatch method on that store object to send actions to it, or to get the current state.



You can either use it directly, but that would be a little bit &#8220;cumbersome&#8221; using React. What most people are doing is to create the store, and then add it to the Provider component in React-Redux. And then use connect.



The way this works is that Provider add your store as a context, and then the connect function, component or what ever use it, and you first run it through a function where you chose what properties from the state you need, and then you run the function that returns with your component as a argument. It can also map any methods to dispatch.



Or, if you don&#8217;t want to do that, the dispatch method will be available as a prop on all component you run through connect.



A few implementation tips at the end. Don&#8217;t connect props you don&#8217;t need, and only connect them where they are needed. There is no need for passing stuff down through long component structures with Redux. And make multiple smaller reducers rather than a few large ones. One patter I&#8217;m a huge fan of is to use a higher order function to make a re-usable reducer for everything related to lists, with the redux part being re-usable and the matching and talking with backend functions as params.



Remember, you can actually test your reducers without hooking it up to redux, since it&#8217;s just a plain javascript function.@



The next post will be redux example.